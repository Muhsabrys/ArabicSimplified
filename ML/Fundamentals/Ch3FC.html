<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Classification Flashcards</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-blue': '#4c51bf',
                        'secondary-green': '#10b981',
                        'dark-bg': '#1e293b', // Slate-800 equivalent
                        'card-bg': '#ffffff',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Apply Inter font globally and setup background */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f1f5f9; /* Slate-100 */
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            overflow-x: hidden;
        }

        /* Custom styles for the card flip effect */
        .flashcard-container {
            width: 100%;
            height: 450px;
            max-width: 600px;
            perspective: 1000px;
            position: relative;
            margin: 0 auto;
        }
        .flashcard {
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
            cursor: pointer;
        }
        .is-flipped {
            transform: rotateY(180deg);
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 1.5rem; /* rounded-3xl */
            padding: 2rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            transition: box-shadow 0.3s;
        }
        .card-front {
            background-color: #f8fafc; /* White/Light */
            color: #1e293b; /* Dark text */
            border: 2px solid #e2e8f0;
        }
        .card-back {
            background-color: #4c51bf; /* Primary Blue */
            color: white;
            transform: rotateY(180deg);
            border: 2px solid #3d429a;
        }

        /* Card Stack Effect */
        .card-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 1.5rem;
            background: #cbd5e1; /* Slate-300 */
            z-index: -1;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        .card-bg-1 {
            transform: translate(8px, 8px);
            background: #94a3b8; /* Slate-400 */
        }
        .card-bg-2 {
            transform: translate(16px, 16px);
            background: #64748b; /* Slate-500 */
        }
        @media (min-width: 640px) {
            .card-bg-1 { transform: translate(12px, 12px); }
            .card-bg-2 { transform: translate(24px, 24px); }
        }

        /* Blob Backgrounds (for visual aesthetic) */
        .blob {
            position: fixed;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            opacity: 0.5;
            filter: blur(100px);
            z-index: -2;
        }
        .blob-green {
            background-color: #10b981;
            top: -50px;
            left: -50px;
        }
        .blob-blue {
            background-color: #4c51bf;
            bottom: -50px;
            right: -50px;
        }

        /* Custom icons for the buttons - Using unicode arrows as a simple fallback */
        .nav-button-icon {
            font-size: 24px;
            line-height: 1;
        }

        /* MathJax styling for visibility and size */
        .card-back-content .MathJax {
            color: white !important;
            font-size: 1.5rem !important; /* Larger for formulas */
            overflow-x: auto;
            max-width: 100%;
            display: inline-block;
        }

        /* Ensure content doesn't overflow */
        .max-h-full {
            max-height: calc(100% - 2rem);
            overflow-y: auto; /* Allow scrolling for long answers */
        }
        .card-back-content {
            font-size: 1.25rem;
        }
    </style>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'a']
        }
      };
    </script>
</head>
<body class="font-sans">

    <div class="blob blob-green"></div>
    <div class="blob blob-blue"></div>

    <main class="w-full max-w-2xl mx-auto py-10">
        <h1 class="text-4xl font-extrabold text-center mb-8 text-primary-blue tracking-tight">
            üìä ML Classification Flashcards
        </h1>

        <div class="flashcard-container">

            <div class="card-bg card-bg-2"></div>
            <div class="card-bg card-bg-1"></div>

            <div id="flashcard" class="flashcard" onclick="flipCard()">
                <div class="card-face card-front">
                    <p class="text-xs font-semibold uppercase text-secondary-green mb-2" id="card-status-front">Question <span id="current-index-front">1</span> / <span id="total-cards-front">56</span></p>
                    <div class="max-h-full overflow-y-auto flex items-center justify-center">
                        <p id="card-question" class="text-2xl font-bold leading-relaxed text-dark-bg">
                            What are the two most common supervised learning tasks mentioned in the text?
                        </p>
                    </div>
                    <p class="text-sm mt-4 text-gray-500">Click to reveal the answer</p>
                </div>

                <div class="card-face card-back">
                    <p class="text-xs font-semibold uppercase text-white opacity-75 mb-2" id="card-status-back">Answer <span id="current-index-back">1</span> / <span id="total-cards-back">56</span></p>
                    <div class="max-h-full overflow-y-auto flex items-center justify-center">
                        <p id="card-answer" class="font-medium leading-relaxed card-back-content">
                            Regression (predicting values) and classification (predicting classes).
                        </p>
                    </div>
                    <p class="text-sm mt-4 text-white opacity-75">Click to return to the question</p>
                </div>
            </div>
        </div>

        <div class="flex justify-center items-center space-x-6 mt-10">
            <button id="prev-btn" onclick="navigateCard(-1)"
                    class="flex items-center space-x-2 px-6 py-3 bg-white text-primary-blue border border-primary-blue rounded-full shadow-lg hover:bg-gray-100 transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                <span class="nav-button-icon">‚Üê</span>
                <span class="font-semibold">Previous</span>
            </button>
            <button id="next-btn" onclick="navigateCard(1)"
                    class="flex items-center space-x-2 px-6 py-3 bg-primary-blue text-white rounded-full shadow-lg hover:bg-indigo-700 transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                <span class="font-semibold">Next</span>
                <span class="nav-button-icon">‚Üí</span>
            </button>
        </div>
    </main>

    <script>
        // Data structure for flashcards
        const flashcardsData = [
  {
    "front": "What are the two most common supervised learning tasks?",
    "back": "Regression (predicting continuous values) and classification (predicting discrete classes or categories)."
  },
  {
    "front": "What is a binary classifier?",
    "back": "A classifier capable of distinguishing between exactly two classes (e.g., 'spam' vs 'not spam', 'positive' vs 'negative')."
  },
  {
    "front": "What is a multiclass (multinomial) classifier?",
    "back": "A classifier that can distinguish between more than two classes (e.g., classifying images into categories like cat, dog, bird, etc.)."
  },
  {
    "front": "What is a skewed dataset in classification?",
    "back": "A dataset where some classes are much more frequent than others (class imbalance), which can lead to misleading accuracy metrics."
  },
  {
    "front": "What is a confusion matrix?",
    "back": "A table that shows the number of correct and incorrect predictions made by a classifier, broken down by actual class and predicted class."
  },
  {
    "front": "In a confusion matrix, what do rows and columns represent?",
    "back": "Each row represents an actual class, while each column represents a predicted class."
  },
  {
    "front": "What would a perfect classifier's confusion matrix look like?",
    "back": "It would have nonzero values only on the main diagonal (from top-left to bottom-right), indicating all predictions were correct."
  },
  {
    "front": "Define: True Positives (TP)",
    "back": "Instances of the positive class that were correctly classified as positive."
  },
  {
    "front": "Define: False Positives (FP)",
    "back": "Instances of the negative class that were incorrectly classified as positive (Type I error)."
  },
  {
    "front": "Define: False Negatives (FN)",
    "back": "Instances of the positive class that were incorrectly classified as negative (Type II error)."
  },
  {
    "front": "Define: True Negatives (TN)",
    "back": "Instances of the negative class that were correctly classified as negative."
  },
  {
    "front": "Why is accuracy often not the best metric for classification, especially with imbalanced datasets?",
    "back": "A classifier can achieve high accuracy by simply predicting the most frequent class for all instances, missing the minority class entirely."
  },
  {
    "front": "What is precision in classification?",
    "back": "The accuracy of positive predictions; the ratio of true positives to all positive predictions. Formula: Precision = TP / (TP + FP)"
  },
  {
    "front": "What is recall (sensitivity) in classification?",
    "back": "The ratio of positive instances that are correctly detected. Formula: Recall = TP / (TP + FN). Also called the true positive rate (TPR)."
  },
  {
    "front": "What is the F1 score?",
    "back": "The harmonic mean of precision and recall, providing a single score that balances both metrics. Formula: F1 = 2 √ó (precision √ó recall) / (precision + recall)"
  },
  {
    "front": "When will a classifier get a high F1 score?",
    "back": "Only when both precision and recall are high. The F1 score penalizes classifiers that have either low precision or low recall."
  },
  {
    "front": "What is specificity?",
    "back": "The true negative rate (TNR); the ratio of negative instances that are correctly identified as negative. Specificity = TN / (TN + FP)"
  },
  {
    "front": "What is the precision/recall trade-off?",
    "back": "The inverse relationship where increasing precision typically reduces recall and vice versa. You can adjust this trade-off by changing the decision threshold."
  },
  {
    "front": "How does raising the decision threshold affect precision and recall?",
    "back": "It generally increases precision (fewer false positives) but decreases recall (more false negatives)."
  },
  {
    "front": "How does lowering the decision threshold affect precision and recall?",
    "back": "It generally decreases precision (more false positives) but increases recall (fewer false negatives)."
  },
  {
    "front": "When would you prioritize high precision over high recall?",
    "back": "When false positives are very costly (e.g., spam detection where legitimate emails must not be blocked, medical diagnosis where false alarms cause unnecessary worry)."
  },
  {
    "front": "When would you prioritize high recall over high precision?",
    "back": "When false negatives are very costly (e.g., fraud detection, disease screening, security threats where missing a positive case is dangerous)."
  },
  {
    "front": "What does the ROC (Receiver Operating Characteristic) curve plot?",
    "back": "It plots the True Positive Rate (TPR/Recall) against the False Positive Rate (FPR) at various threshold settings."
  },
  {
    "front": "What is the False Positive Rate (FPR)?",
    "back": "The ratio of negative instances incorrectly classified as positive. FPR = FP / (FP + TN) = 1 - Specificity"
  },
  {
    "front": "What does the Area Under the ROC Curve (AUC) measure?",
    "back": "A single-number summary of classifier performance. Perfect classifier: AUC = 1.0, Random classifier: AUC = 0.5, Worse than random: AUC < 0.5"
  },
  {
    "front": "When should you prefer the Precision-Recall curve over the ROC curve?",
    "back": "When dealing with highly imbalanced datasets where the positive class is rare, or when you care more about the performance on the positive class."
  },
  {
    "front": "What is the One-vs-Rest (OvR) strategy for multiclass classification?",
    "back": "Train one binary classifier for each class against all other classes combined, then select the class whose classifier outputs the highest confidence score."
  },
  {
    "front": "What is the One-vs-One (OvO) strategy for multiclass classification?",
    "back": "Train a binary classifier for every pair of classes, then classify by voting - the class that wins the most pairwise comparisons is selected."
  },
  {
    "front": "How many binary classifiers does OvO require for N classes?",
    "back": "N √ó (N-1) / 2 classifiers. For example, 10 classes would require 45 binary classifiers."
  },
  {
    "front": "What is the main advantage of the OvO strategy?",
    "back": "Each classifier only trains on data from two classes, making it faster for algorithms that don't scale well with dataset size, and potentially more accurate for complex decision boundaries."
  },
  {
    "front": "What is multilabel classification?",
    "back": "A classification system where each instance can belong to multiple classes simultaneously (e.g., tagging an article with multiple topics)."
  },
  {
    "front": "What is multioutput classification?",
    "back": "A generalization where each instance has multiple outputs, and each output can be multiclass (more than binary). Example: predicting multiple attributes of an object."
  },
  {
    "front": "What is data augmentation in the context of classification?",
    "back": "The technique of artificially expanding the training set by creating modified versions of existing data (e.g., rotating, scaling, or adding noise to images)."
  },
  {
    "front": "What is stratified sampling in cross-validation?",
    "back": "A sampling technique that ensures each fold contains approximately the same percentage of samples from each class as the complete dataset, maintaining class distribution."
  },
  {
    "front": "What is a key step in error analysis for a classifier?",
    "back": "Examining the confusion matrix to identify patterns in misclassification, understanding which classes are commonly confused with each other."
  },
  {
    "front": "How can you analyze errors in a multiclass confusion matrix?",
    "back": "Normalize by dividing each value by the number of instances in the actual class, then look for bright spots off the diagonal to identify common confusions."
  },
  {
    "front": "What is the effect of feature scaling on classification performance?",
    "back": "Proper feature scaling (e.g., standardization or normalization) often significantly improves classifier performance, especially for distance-based algorithms."
  },
  {
    "front": "What is a decision function in classification?",
    "back": "A function that computes a score for each instance; the classifier assigns the instance to a class based on whether this score exceeds a threshold."
  },
  {
    "front": "What's the difference between decision_function() and predict_proba()?",
    "back": "decision_function() returns a score (can be any real number), while predict_proba() returns probability estimates between 0 and 1 for each class."
  },
  {
    "front": "Why might shuffling training data be beneficial?",
    "back": "It ensures that cross-validation folds are similar and prevents algorithms sensitive to instance order from learning spurious patterns."
  },
  {
    "front": "When should you NOT shuffle your training data?",
    "back": "For time series data or any sequential data where the order contains important information (e.g., stock prices, weather patterns, text sequences)."
  },
  {
    "front": "What are some ways to handle class imbalance?",
    "back": "Resampling (over-sampling minority or under-sampling majority), using class weights, choosing appropriate metrics (F1, AUC), or using ensemble methods like SMOTE."
  }
        ];

        let currentCardIndex = 0;
        const totalCards = flashcardsData.length;
        const flashcardElement = document.getElementById('flashcard');
        const questionElement = document.getElementById('card-question');
        const answerElement = document.getElementById('card-answer');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');

        /**
         * Renders the current flashcard data to the DOM and updates navigation status.
         */
        function renderCard() {
            const card = flashcardsData[currentCardIndex];
            const currentIndexDisplay = currentCardIndex + 1;

            questionElement.innerHTML = card.f;
            answerElement.innerHTML = card.b;

            // Update status indicators
            document.getElementById('current-index-front').textContent = currentIndexDisplay;
            document.getElementById('total-cards-front').textContent = totalCards;
            document.getElementById('current-index-back').textContent = currentIndexDisplay;
            document.getElementById('total-cards-back').textContent = totalCards;

            // Re-render MathJax. Use MathJax.typesetPromise for asynchronous rendering
            if (window.MathJax) {
                // Clear previous MathJax output before re-rendering
                MathJax.texReset();
                MathJax.typesetClear([questionElement, answerElement]);
                MathJax.typesetPromise([questionElement, answerElement]).catch((err) => console.error("MathJax typesetting failed: " + err.message));
            }


            // Update button disabled state
            prevBtn.disabled = currentCardIndex === 0;
            nextBtn.disabled = currentCardIndex === totalCards - 1;
        }

        /**
         * Flips the flashcard.
         */
        function flipCard() {
            flashcardElement.classList.toggle('is-flipped');
        }

        /**
         * Navigates to the next or previous card.
         * @param {number} direction - 1 for next, -1 for previous.
         */
        function navigateCard(direction) {
            const newIndex = currentCardIndex + direction;

            if (newIndex >= 0 && newIndex < totalCards) {
                // If card is flipped, flip it back before navigating
                if (flashcardElement.classList.contains('is-flipped')) {
                    flashcardElement.classList.remove('is-flipped');
                    // Wait for the flip animation to finish before updating content
                    setTimeout(() => {
                        currentCardIndex = newIndex;
                        renderCard();
                    }, 300); // 300ms is half of the flip transition time (0.6s)
                } else {
                    currentCardIndex = newIndex;
                    renderCard();
                }
            }
        }

        // Initial load
        document.addEventListener('DOMContentLoaded', () => {
            renderCard();
        });
    </script>
</body>
</html>
